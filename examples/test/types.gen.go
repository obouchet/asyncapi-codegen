// Package "main" provides primitives to interact with the AsyncAPI specification.
//
// Code generated by github.com/obouchet/asyncapi-codegen version (devel) DO NOT EDIT.
package main

import (
	"encoding/json"
	"time"

	"github.com/obouchet/asyncapi-codegen/pkg/extensions"
)

// MessageMessage is the message expected for 'Message' channel
// test message
type MessageMessage struct {
	// Headers will be used to fill the message headers
	Headers HeaderSchemaSchema

	// Payload will be inserted in the message payload
	Payload struct {
		Prop1 struct {
			// Description: Unique Id used as an alias to the card number.
			ReferenceID string `json:"referenceId" validate:"required"`
		} `json:"prop1"`
	}
}

func NewMessageMessage() MessageMessage {
	var msg MessageMessage

	return msg
}

// newMessageMessageFromBrokerMessage will fill a new MessageMessage with data from generic broker message
func newMessageMessageFromBrokerMessage(bMsg extensions.BrokerMessage) (MessageMessage, error) {
	var msg MessageMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "dateTime": // Retrieving DateTime header
			t, err := time.Parse(time.RFC3339, string(v))
			if err != nil {
				return msg, err
			}
			msg.Headers.DateTime = t
		case k == "version": // Retrieving Version header
			msg.Headers.Version = string(v)
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from MessageMessage data
func (msg MessageMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 0)

	// Adding DateTime header
	headers["dateTime"] = []byte(msg.Headers.DateTime.Format(time.RFC3339)) // Adding Version header
	headers["version"] = []byte(msg.Headers.Version)

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// HeaderSchemaSchema is a schema from the AsyncAPI specification required in messages
// Description: header
type HeaderSchemaSchema struct {
	// Description: Date when the event was generated. UTC format "YYYY-MM-DDThh:mm:ss.sZ".
	DateTime time.Time `json:"dateTime" validate:"required"`

	// Description: Schema version
	Version string `json:"version" validate:"required"`
}

// TestSchemaSchema is a schema from the AsyncAPI specification required in messages
type TestSchemaSchema struct {
	Prop1 struct {
		// Description: Unique Id used as an alias to the card number.
		ReferenceID string `json:"referenceId" validate:"required"`
	} `json:"prop1"`
}
